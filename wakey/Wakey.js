let msg = "PLEASE CONNECT TO MR WAKEY";
let serialOptions = { baudRate: 9600 };
let serial;
let isConnected = false;
let anger = false;
let voice
let voicePlayed = false;
let sorryCol = 255
let buttonBounds = { x: 0, y: 0, w: 0, h: 0 }; 

let pitch = 0;
let roll = 0;

let greenColor, orangeColor, redColor, grayColor;

let angerStartTime = null;
const angerDelay = 5000;

function preload() {
    voice = loadSound('Wakey.mp3');
}

function setup() {
  createCanvas(windowWidth, windowHeight);
  textFont('Verdana');
  textSize(60);

  greenColor = color(0, 200, 0);
  orangeColor = color(255, 165, 0);
  redColor = color(255, 0, 0);
  grayColor = color(100);

let recalButton = createButton("Recalibrate");
recalButton.position(20, 90); 
recalButton.class("button")

recalButton.mousePressed(() => {
  if (serial && serial.isOpen()) {
    serial.writeLine("recalibrate");
    msg = "Recalibration command sent!";
  } else {
    msg = "Serial not connected!";
  }
});

//SERIAL EVENT CODES WAS TAKEN FROM https://github.com/matildasutho/matildasutho.github.io/blob/main/InteractiveMedia2024/Week9-serial/serial_port/serial_port.js
  serial = new Serial();
  serial.on(SerialEvents.CONNECTION_OPENED, onSerialConnectionOpened);
  serial.on(SerialEvents.CONNECTION_CLOSED, onSerialConnectionClosed);
  serial.on(SerialEvents.DATA_RECEIVED, onSerialDataReceived);
  serial.on(SerialEvents.ERROR_OCCURRED, onSerialErrorOccurred);
}

function draw() {
//VAL calculation code was assisted by Chatgpt
  let maxVal = Math.max(Math.abs(pitch), Math.abs(roll));

  if (maxVal > 30) {
    if (angerStartTime === null) {
      angerStartTime = millis();
    } else {
      if (millis() - angerStartTime >= angerDelay) {
        anger = true;
      }
    }
  } else {
    angerStartTime = null;
  }

  if (anger) {
    maxVal = 30;
  }

  let mouthOffset = map(maxVal, 0, 30, 0, 60);
  mouthOffset = constrain(mouthOffset, 0, 60);

  let eyebrowRotation = 0;
  if (maxVal > 10) {
    eyebrowRotation = map(maxVal, 10, 30, 0, PI / 6);
    eyebrowRotation = constrain(eyebrowRotation, 0, PI / 6);
  }

  if (anger) {
    background(redColor);
  if (!voicePlayed) {
    voice.play();
    voicePlayed = true;
  }
  } else {
    background('lightBlue');
  if (voice.isPlaying()) {
    voice.stop();
  }
  voicePlayed = false;
  }
    
  textSize(30);
  fill('white');
  textAlign(LEFT, TOP);
  text(msg, 20, 20);

//face
  fill(BgColor(maxVal));
  noStroke();
  ellipse(width / 2, height / 2, 800, 800);

//eye
  fill('white');
  ellipse(width / 2 - 150, height / 2 - 125, 150, 150);
  ellipse(width / 2 + 150, height / 2 - 125, 150, 150);

//pupil PUPIL CODE HAS BEEN GENERATED BY CHATGPT
let leftEyeX = width / 2 - 150;
let leftEyeY = height / 2 - 125;
let rightEyeX = width / 2 + 150;
let rightEyeY = height / 2 - 125;
let pupilRadius = 80;
let eyeRadius = 75;
let pupilOffsetLimit = 20;

function getPupilOffset(eyeX, eyeY) {
  let dx = mouseX - eyeX;
  let dy = mouseY - eyeY;
  let angle = atan2(dy, dx);
  let distance = min(dist(mouseX, mouseY, eyeX, eyeY), pupilOffsetLimit);
  return {
    x: cos(angle) * distance,
    y: sin(angle) * distance
  };
}

let leftOffset = getPupilOffset(leftEyeX, leftEyeY);
let rightOffset = getPupilOffset(rightEyeX, rightEyeY);

fill('black');
ellipse(leftEyeX + leftOffset.x, leftEyeY + leftOffset.y, pupilRadius, pupilRadius);
ellipse(rightEyeX + rightOffset.x, rightEyeY + rightOffset.y, pupilRadius, pupilRadius);

  
//eyebrow left
  push();
  translate(width / 2 - 150, height / 2 - 200);
  rotate(eyebrowRotation);
  fill('black');
  rectMode(CENTER);
  rect(0, 0, 200, 20, 10);
  pop();

//eyebrow right
  push();
  translate(width / 2 + 150, height / 2 - 200);
  rotate(-eyebrowRotation);
  fill('black');
  rectMode(CENTER);
  rect(0, 0, 200, 20, 10);
  pop();

//mouth
  push();
  fill('black');
  translate(width / 2, height / 2 + 50 + mouthOffset);
  rectMode(CENTER);
  rect(0, 0, 300 + mouthOffset * 3, 50);
  pop();

if (anger) {
  fill('white');
  textAlign(CENTER, CENTER);
  textSize(80);
  text("!!! IM DISAPPOINTED IN YOU !!!", width / 2, height / 2 + 35);

  let buttonText = "I'm Sorry";
  textSize(50);
  let buttonX = width / 2;
  let buttonY = height - 60;

 // THIS FUNCTION WAS GENERATED BY CHATGPT
  let textW = textWidth(buttonText);
  buttonBounds = {
    x: buttonX - textW / 2,
    y: buttonY - 20,
    w: textW,
    h: 40,
  };

  if (
    mouseX >= buttonBounds.x &&
    mouseX <= buttonBounds.x + buttonBounds.w &&
    mouseY >= buttonBounds.y &&
    mouseY <= buttonBounds.y + buttonBounds.h
  ) {
    sorryCol = "black";
    cursor(HAND);
  } else {
    sorryCol = "white";
    cursor(ARROW);
  }

  fill(sorryCol);
  textAlign(CENTER, CENTER);
  text(buttonText, buttonX, buttonY);
  }
}

//FUNCTION LOGIC HAS BEEN GENERATED WITH CHATGPT
function BgColor(val) {
  let absVal = Math.abs(val);

  if (absVal <= 10) {
    return greenColor;
  } else if (absVal <= 20) {
    let amt = map(absVal, 10, 20, 0, 1);
    return lerpColor(greenColor, orangeColor, amt);
  } else if (absVal <= 30) {
    let amt = map(absVal, 20, 30, 0, 1);
    return lerpColor(orangeColor, redColor, amt);
  } else {
    return redColor;
  }
}

function mouseClicked() {
  if (!isConnected) {
    isConnected = connectPort();
  }

  if (anger) {
    if (
      mouseX >= buttonBounds.x &&
      mouseX <= buttonBounds.x + buttonBounds.w &&
      mouseY >= buttonBounds.y &&
      mouseY <= buttonBounds.y + buttonBounds.h
    ) {
      anger = false;
    }
  }
}

//Async functions and other serial related functions were taken from https://github.com/matildasutho/matildasutho.github.io/blob/main/InteractiveMedia2024/Week9-serial/serial_port/serial_port.js
async function connectPort() {
  if (!serial.isOpen()) {
    await serial.connectAndOpen(null, serialOptions);
  } else {
    serial.autoConnectAndOpenPreviouslyApprovedPort(serialOptions);
  }
}

function onSerialConnectionOpened(eventSender) {
  console.log("Serial connection opened");
  msg = "Connected!";
}

function onSerialConnectionClosed(eventSender) {
  console.log("Serial connection closed");
  msg = "Connection Closed!";
  isConnected = false;
}

function onSerialErrorOccurred(eventSender, error) {
  console.error("Serial error", error);
  msg = "Serial Error Occurred. Please Refresh!";
}

function onSerialDataReceived(eventSender, newData) {
  newData = newData.trim();
  console.log("Received:", newData);

  if (newData.startsWith("PITCH:")) {
    let parts = newData.split(",");
    if (parts.length === 2) {
      let pitchPart = parts[0].split(":");
      let rollPart = parts[1].split(":");
      if (pitchPart.length === 2 && rollPart.length === 2) {
        pitch = parseFloat(pitchPart[1]);
        roll = parseFloat(rollPart[1]);
        msg = `Pitch: ${pitch.toFixed(2)}, Roll: ${roll.toFixed(2)}`;
      }
    }
  } else {
    msg = "Received: " + newData;
  }
}
